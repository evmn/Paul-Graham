<html lang="en">
 <head>
  <title>
   Accumulator Generator
  </title>
 </head>
 <body>
  <h1>
   Accumulator Generator
  </h1>
  <p>
   <a href="icad.html">
    Revenge of the Nerds
   </a>
   yielded a 
collection of canonical solutions to the same problem in 
a number of languages.
  </p>
  <p>
   The problem: Write a function foo that takes a number n and returns a 
function that takes a number i, and returns n incremented by i.
  </p>
  <p>
   Note: (a) that's
   <i>
    number,
   </i>
   not integer, (b) that's
   <i>
    incremented by,
   </i>
   not 
plus.
   <xmp>
    C++                   template
    <typename t="">
     struct Acc {
                        Acc(T n)
                        : n(n) {}
    </typename>
   </xmp>
   <xmp>
    template
    <typename u="">
     Acc(const Acc
     <u>
      &amp; u)
                        : n(u.n) {}
     </u>
    </typename>
   </xmp>
   <xmp>
    template
    <typename u="">
     T operator()(U i) {
                            return n += i;
                        }
    </typename>
   </xmp>
   <xmp>
    T n;
                      };
   </xmp>
   <xmp>
    template
    <typename t="">
     Acc
     <t>
      foo(T n)
                      {
                        return Acc
      <t>
       (n);
                      }
      </t>
     </t>
    </typename>
   </xmp>
   <xmp>
    Dylan                 define function foo (n)
                        method (i) n := n + i end;
                      end function;
   </xmp>
   <xmp>
    E                     def foo (var n) :any {
                        def inc (i) :any { n += i }
                      }
   </xmp>
   <xmp>
    Erlang                foop(N)-&gt;
                        receive
                          {P,I}-&gt; S =N+I, P!S, foop(S)
                        end.
   </xmp>
   <xmp>
    foo(N)-&gt;
                        P=spawn(foo,foop,[N]),
                        fun(I)-&gt;
                          P!{self(),I},
                          receive V-&gt;V end
                        end.
   </xmp>
   <xmp>
    Haskell               import IOExts
                      foo n = do
                        r &lt;- newIORef n
                        return (\i -&gt; do
                          modifyIORef r (+i)
                          readIORef r)
   </xmp>
   <xmp>
    Javascript            function foo (n) {
                        return function (i) {
                                 return n += i } }
   </xmp>
   <xmp>
    Lisp: Arc             (def foo (n) [++ n _])
   </xmp>
   <xmp>
    Lisp: Common Lisp     (defun foo (n) 
                        (lambda (i) (incf n i)))
   </xmp>
   <xmp>
    Lisp: Goo             (df foo (n) (op incf n _))
   </xmp>
   <xmp>
    Lisp: Scheme          (define (foo n)
                        (lambda (i)
                          (set! n (+ n i))
                          n))
   </xmp>
   <xmp>
    Lua                   function foo(n)
                        return function (i)
                                 n = n + i
                                 return n
                               end
                      end
   </xmp>
   <xmp>
    Maple                 foo := proc(n)
                               local s;
                               s := n;
                               proc(i) s := s + i   
                                 end
                             end
   </xmp>
   <xmp>
    Mathematica           foo = Module[{s=#},s+=# &amp;] &amp;
   </xmp>
   <xmp>
    Mozart                fun {Foo N}
                        A = {NewCell N}
                      in
                         fun {$ B} C D in
                            {Exchange A C D}
                            if {IsInt C}
                               andthen {IsFloat B}
                            then
                               D = {IntToFloat C}+B
                            elseif {IsFloat C}
                               andthen {IsInt B}
                            then
                               D = C+{IntToFloat B}
                            else D = C+B end
                            {Access A}
                         end
                      end
   </xmp>
   <xmp>
    NewtonScript          foo := func (n)
                               func (i)
                                 n := n + i ;
   </xmp>
   <xmp>
    Perl 5                sub foo {
                        my ($n) = @_;
                        sub {$n += shift}
                      }
   </xmp>
   <xmp>
    Python                class foo:
                        def __init__(self, n):
                            self.n = n
                        def __call__(self, i):
                            self.n += i
                            return self.n
   </xmp>
   <xmp>
    Rebol                 foo: func [ n ] 
                       [ func [ i ] [ n: n + i ] ]
   </xmp>
   <xmp>
    Ruby                  def foo (n)
                        lambda {|i| n += i } end
   </xmp>
   <xmp>
    Smalltalk             foo: n
                        |s|
                        s := n.
                        ^[:i| s := s + i. ]
   </xmp>
   <xmp>
    VBScript              Class acc
                        Private n
                        Public Default Function inc(i)
                          n = n + i
                          inc = n
                        End Function
                      End Class
   </xmp>
   <xmp>
    Function foo(n)
                        Dim bar
                        Set bar = New acc
                        bar(n)
                        Set foo = bar
                      End Function
   </xmp>
  </p>
  <p>
   Some languages are not represented here, either because you
can't write this program in them (short of Greenspun's Tenth Rule)
or because no one has yet sent me the code for that language.
   <!--
If you know how to write this program in a language that isn't listed here, 
please <a href="accgensub.html">send it along</a>.  -->
  </p>
  <p>
   Please don't send may any new submissions for the time being; I
don't have time to look at them.
  </p>
  <p>
   Credits: C++, Brendan Corfman and Daniel Cowgill;
Dylan, Neel Krishnaswami; E, Darius Bacon; 
Erlang, Heinz Eriksson; Goo, Jonathan Bachrach; Haskell, Malcolm Wallace
and Tom Pledger;
Javascript, Anton van Straaten;  Lua, Chris Laurel; Maple, Stefan Vorkoetter;
Mathematica, Kovas Boguta;
Mozart, Kari Pahula; NewtonScript, Sean Luke;
Perl, Dan Giffin and Trevor Blackwell; Python, Jeremy Hylton; 
Rebol, Andreas Bolka; 
Ruby, Stephan Schmidt; 
Smalltalk, Trevor Blackwell; VBScript, Stefan Holm.
  </p>
  <p>
  </p>
 </body>
</html>